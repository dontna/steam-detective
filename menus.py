import time, os, commands.screenshot_scraper

### GLOBAL VARIABLES ###
global_sleep_time = 2 # The amount of seconds the error text will show on a menu, before continuing the loop.

TEXT_FORMATTING_DICTIONARY = {
    'bold':'\033[1m',
    'normal':'\033[0m'
}

TEXT_COLOUR_DICTIONARY = {
    'green':'\033[32m',
    'blue':'\033[34m',
    'red':'\033[31m'
}

###  END OF GLOBALS  ###

def init_menu_main():
    return_data: tuple
    while True:
        os.system("cls" if os.name == 'nt' else 'clear') # Select the correct way to clear a screen, based on OS
        
        print("Welcome to Steam Detective\nTo start, select one of the options below.")
        print(f'''Are you entering a Custom Steam ID or a Profile ID?
                
                A {TEXT_FORMATTING_DICTIONARY['bold']}{TEXT_COLOUR_DICTIONARY['blue']}Custom Steam ID{TEXT_FORMATTING_DICTIONARY['normal']}, is one a user has created themselves.
                A {TEXT_FORMATTING_DICTIONARY['bold']}{TEXT_COLOUR_DICTIONARY['blue']}Non-Custom Steam ID{TEXT_FORMATTING_DICTIONARY['normal']} is a random set of numbers, generated by Valve when a user creates their Steam account.

                {TEXT_FORMATTING_DICTIONARY['bold']}1. {TEXT_COLOUR_DICTIONARY['blue']}Custom Steam ID{TEXT_FORMATTING_DICTIONARY['normal']}
                {TEXT_FORMATTING_DICTIONARY['bold']}2. {TEXT_COLOUR_DICTIONARY['blue']}Non-Custom Steam ID{TEXT_FORMATTING_DICTIONARY['normal']}
                {TEXT_FORMATTING_DICTIONARY['bold']}0. Exit{TEXT_FORMATTING_DICTIONARY['normal']}
            ''')
    
        choice = input(f"Please select an option: {TEXT_FORMATTING_DICTIONARY['bold']}{TEXT_COLOUR_DICTIONARY['green']}")
        print(f"{TEXT_FORMATTING_DICTIONARY['normal']}")

        if not choice.isnumeric():
            print("Your option should only be a number, please try again.")
            time.sleep(global_sleep_time)
            continue

        if int(choice) == 1:
            return_data = init_menu_custom_id()
            break
        elif int(choice) == 2:
            return_data = init_menu_steam_id()
            break
        elif int(choice) == 0:
            return exit()
            break
        else:
            print(f"'{choice}' isn't a valid option, please try again.")
            time.sleep(global_sleep_time)
            continue

    return return_data

def init_menu_custom_id():
    while True:
        os.system("cls" if os.name == 'nt' else 'clear') # Select the correct way to clear a screen, based on OS
        print(f"You have selected to use a {TEXT_FORMATTING_DICTIONARY['bold']}{TEXT_COLOUR_DICTIONARY['blue']}Custom Steam ID{TEXT_FORMATTING_DICTIONARY['normal']}, if this is wrong please go back.\nOtherwise please enter the Custom Steam ID\n0. Back")
        choice = input(f"Enter Custom Steam ID: {TEXT_FORMATTING_DICTIONARY['bold']}{TEXT_COLOUR_DICTIONARY['green']}")
        print(f"{TEXT_FORMATTING_DICTIONARY['normal']}")

        if choice == "0" or choice == 0:
            init_menu_main()
            break
        
        if choice == "":
            print(f"Please enter the Steam ID, before pressing enter.")
            time.sleep(global_sleep_time)
            continue

        return (choice, True)

def init_menu_steam_id():
        while True:
            os.system("cls" if os.name == 'nt' else 'clear') # Select the correct way to clear a screen, based on OS
            print(f"You have selected to use a {TEXT_FORMATTING_DICTIONARY['bold']}{TEXT_COLOUR_DICTIONARY['blue']}Non-Custom Steam ID{TEXT_FORMATTING_DICTIONARY['normal']}, if this is wrong please go back.\nOtherwise please enter the ID\n0. Back")
            choice = input(f"Enter Non-Custom Steam ID: {TEXT_FORMATTING_DICTIONARY['bold']}{TEXT_COLOUR_DICTIONARY['green']}")
            print(f"{TEXT_FORMATTING_DICTIONARY['normal']}")

            if choice == "0" or choice == 0:
                init_menu_main()
                break
            
            if not choice.isnumeric():
                print("A Profile ID cannot contain any non-number characters, please try again.")
                time.sleep(global_sleep_time)
                continue

            return (choice, False)
master_folder_name = ""
def main_menu(general_info_data: dict, steam_id: str, using_custom_id: bool, folder_path: str):
    filename = steam_id
    show_update_messages = True

    global master_folder_name

    if master_folder_name == "":
        master_folder_name = steam_id

    while True:
        os.system("cls" if os.name == 'nt' else 'clear') # Select the correct way to clear a screen, based on OS
        print(f'''Steam account we are getting information about
        Steam Alias: {TEXT_FORMATTING_DICTIONARY['bold']}{general_info_data['steam_name']}{TEXT_FORMATTING_DICTIONARY['normal']}
        Steam Bio: {TEXT_FORMATTING_DICTIONARY['bold']}{general_info_data['bio']}{TEXT_FORMATTING_DICTIONARY['normal']}
        Steam Level: {TEXT_FORMATTING_DICTIONARY['bold']}{general_info_data['level']}{TEXT_FORMATTING_DICTIONARY['normal']}

        If this is the correct account, type '{TEXT_FORMATTING_DICTIONARY['bold']}start{TEXT_FORMATTING_DICTIONARY['normal']}' otherwise exit and try again.

        Also feel free to change any settings below before starting the scan.

        {TEXT_FORMATTING_DICTIONARY['bold']}Note: the script will create a folder for you, unless there is already one made.{TEXT_FORMATTING_DICTIONARY['normal']}

        TEXT OPTIONS:
        {TEXT_FORMATTING_DICTIONARY['bold']}start {TEXT_COLOUR_DICTIONARY['blue']}Start The Detective, and scrape all data.{TEXT_FORMATTING_DICTIONARY['normal']}
        {TEXT_FORMATTING_DICTIONARY['bold']}screenshots {TEXT_COLOUR_DICTIONARY['blue']}Scrape and Download the users screenshots.{TEXT_FORMATTING_DICTIONARY['normal']}

        NUMERIC OPTIONS:
        {TEXT_FORMATTING_DICTIONARY['bold']}1. {TEXT_COLOUR_DICTIONARY['blue']}Change saved filename {TEXT_FORMATTING_DICTIONARY['normal']}(Currently: {filename}.json)
        {TEXT_FORMATTING_DICTIONARY['bold']}2. {TEXT_COLOUR_DICTIONARY['blue']}Toggle update messages: {TEXT_FORMATTING_DICTIONARY['normal']}(Currently: {"on" if show_update_messages == True else "off"})
        {TEXT_FORMATTING_DICTIONARY['bold']}3. {TEXT_COLOUR_DICTIONARY['blue']}Folder name, where everything will be stored: {TEXT_FORMATTING_DICTIONARY['normal']}(Currently: {master_folder_name})
        {TEXT_FORMATTING_DICTIONARY['bold']}0. Exit{TEXT_FORMATTING_DICTIONARY['normal']}
        ''')

        choice = input(f"Enter your choice: {TEXT_FORMATTING_DICTIONARY['bold']}{TEXT_COLOUR_DICTIONARY['green']}")
        print(f"{TEXT_FORMATTING_DICTIONARY['normal']}")

        if choice == "1":
            os.system("cls" if os.name == 'nt' else 'clear') # Select the correct way to clear a screen, based on OS
            print("Note: Changing the filename will not change it's extention!")
            second_choice = input(f"Enter new filename for output file: {TEXT_COLOUR_DICTIONARY['green']}")
            print(f"{TEXT_FORMATTING_DICTIONARY['normal']}")

            if second_choice == "":
                print("Filename cannot be empty, reverting to last filename.")
                time.sleep(global_sleep_time)
                continue

            if second_choice.startswith(" ") or second_choice.endswith(" "):
                time.sleep(global_sleep_time)
                print("Filename cannot start or end with a space, reverting to last filename.")
                continue

            filename = second_choice
        elif choice == "2":
            show_update_messages = not show_update_messages
            continue
        elif choice == "3":
            os.system("cls" if os.name == 'nt' else 'clear') # Select the correct way to clear a screen, based on OS
            print("Changing the folder name, will not change it's path; even if you specify a path in the name.")
            choice2 = input(f"Enter new folder name: {TEXT_FORMATTING_DICTIONARY['bold']}{TEXT_COLOUR_DICTIONARY['green']}")
            print(f"{TEXT_FORMATTING_DICTIONARY['normal']}")

            if choice2.startswith(" ") or choice2.endswith(" "):
                print("Folder name cannot start or end with  a space.")
                time.sleep(global_sleep_time)
                continue

            master_folder_name = choice2
        elif choice == "start":
            return (filename, show_update_messages, master_folder_name)
        elif choice == "screenshots":
            screenshot_scrape_menu(general_info_data, steam_id, using_custom_id, folder_path, master_folder_name)
        elif choice == "0":
            exit()
        else:
            print(f"Invalid option '{choice}', please try again.")

def screenshot_scrape_menu(general_info_data: dict, steam_id: str, using_custom_id: bool, folder_path: str, parent_folder_name: str):
    num_of_screenshots = int(general_info_data['screenshots'])

    while True:
        os.system("cls" if os.name == 'nt' else 'clear') # Select the correct way to clear a screen, based on OS
        print(f'''You have chosen to scrape and download all screenshots for {TEXT_FORMATTING_DICTIONARY['bold']}{TEXT_COLOUR_DICTIONARY['blue']}{general_info_data['steam_name']}{TEXT_FORMATTING_DICTIONARY['normal']}
        Number of screenshots, that will be downloaded: {TEXT_FORMATTING_DICTIONARY['bold']}{num_of_screenshots}{TEXT_FORMATTING_DICTIONARY['normal']}

        This could take a few minutes for the whole process to finish, depending on how many screenshots there are.

        {TEXT_FORMATTING_DICTIONARY['bold']}1. {TEXT_COLOUR_DICTIONARY['blue']}Start Scraping{TEXT_FORMATTING_DICTIONARY['normal']}
        {TEXT_FORMATTING_DICTIONARY['bold']}0. Back{TEXT_FORMATTING_DICTIONARY['normal']}
        ''')

        choice = input(f"Enter your choice: {TEXT_FORMATTING_DICTIONARY['bold']}{TEXT_COLOUR_DICTIONARY['green']}")
        print(f"{TEXT_FORMATTING_DICTIONARY['normal']}")

        if not choice.isnumeric():
            print("Choice must be a number, try again.")

        if choice == "1":
            commands.screenshot_scraper.scrape_and_download_screenshots(steam_id, using_custom_id, num_of_screenshots, folder_path, parent_folder_name)
            os.system("cls" if os.name == 'nt' else 'clear') # Select the correct way to clear a screen, based on OS
            print(f"{TEXT_FORMATTING_DICTIONARY['bold']}{num_of_screenshots}{TEXT_FORMATTING_DICTIONARY['normal']} screenshots downloaded, and saved in to {TEXT_FORMATTING_DICTIONARY['bold']}'{folder_path}/{parent_folder_name}/screenshots'{TEXT_FORMATTING_DICTIONARY['normal']}")
            no_choice = input("Press enter to continue back to the main menu!")
            break
        elif choice == "0":
            break
        else:
            print(f"Invalid option '{choice}', please try again.")

    
    #main_menu(general_info_data, steam_id, using_custom_id, folder_path)

        
